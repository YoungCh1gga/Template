struct Line
{
    Point s, t;
    Line(Point s = Point(), Point t = Point()) : s(s), t(t) {}
    Point v()
    {
        return t - s;
    }
    double norm()
    {
        return v().norm();
    }
    //点与直线之间的关系 online(0),逆时针(1),顺时针(-1)
    int relation(Point &p)
    {
        return sgn((v() ^ (p - s)));
    }
    bool point_on_line(Point &p)
    { //点是否在直线上(已验)
        return sgn(v() ^ (p - s)) == 0;
    }
    bool point_on_seg(Point &p)
    {                                                           //点是否在线段上
        return point_on_line(p) && sgn((p - s) % (p - t)) <= 0; //包含端点
        // return point_on_line(p) && sgn((p - s) % (p - t)) < 0;//不包含端点
    }
    double dis_point_line(Point &p)
    { //点到直线的距离
        return fabs((v() ^ (p - s)) / norm());
    }
    double dis_point_seg(Point &p)
    { //点到线段的距离
        if (sgn((p - s) % (t - s)) < 0)
            return (p - s).norm();
        if (sgn((p - t) % (s - t)) < 0)
            return (p - t).norm();
        return dis_point_line(p);
    }
    // 判断 a, b 是否在直线的同侧或者同时在直线上
    bool same_side(Point &a, Point &b)
    {
        return relation(a) == relation(b);
    }
    Point pedal(Point &p)
    { //点对直线的垂足
        return s + (p - s) % v() / (v() % v()) * v();
    }
    Point sym_point(Point &p)
    { //点 p 关于直线的对称点
        return 2.0 * pedal(p) - p;
    }

    friend bool isParallel(Line &a, Line &b)
    { //判断两直线是否平行（包括重合）
        return !sgn(a.v() ^ b.v());
    }
    friend bool is_Line_seg_intersection(Line &a, Line &b)
    { //线(a)和线段(b)是否相交（包括端点）(已验)
        return a.relation(b.s) * a.relation(b.t) <= 0;
    }
    //利用相似三角形对应或者成比例求两直线的交点//先判断是否平行，不平行的情况再求交点(已验)
    friend Point line_intersection(Line &a, Line &b)
    {
        double s1 = (a.s - b.s) ^ b.v();
        double s2 = (a.t - b.s) ^ b.v();
        return (a.t * s1 - a.s * s2) / (s1 - s2);
    }

    // 规范相交, 两线段仅有一个非端点处的交点
    // 判断线段相交, 并求线段交点, 1规范相交, 2相交, 0不交
    friend int seg_intersection(Line &a, Line &b, Point &p)
    {
        int d1, d2, d3, d4;
        double s1, s2, s3, s4;
        d1 = sgn(s1 = a.v() ^ (b.s - a.s));
        d2 = sgn(s2 = a.v() ^ (b.t - a.s));
        d3 = sgn(s3 = b.v() ^ (a.s - b.s));
        d4 = sgn(s4 = b.v() ^ (a.t - b.s));

        //规范相交
        if (d1 * d2 < 0 && d3 * d4 < 0)
        {
            p = (b.s * s2 - b.t * s1) / (s2 - s1);
            return 1;
        }

        //非规范相交
        if (a.point_on_seg(b.s) || a.point_on_seg(b.t) || b.point_on_seg(a.s) || b.point_on_seg(b.s))
        {
            return 2;
        }
        return 0;
    }

    //线段之间的最短距离
    friend double dis_seg_seg(Line &a, Line &b)
    {
        double d1, d2, d3, d4;
        Point p;
        if (seg_intersection(a, b, p))
            return 0;
        else
        {
            d1 = a.dis_point_seg(b.s);
            d2 = a.dis_point_seg(b.t);
            d3 = b.dis_point_seg(a.s);
            d4 = b.dis_point_seg(a.t);
            return min(min(d1, d2), min(d3, d4));
        }
    }
};